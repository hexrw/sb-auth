var x = Object.defineProperty;
var T = (t, e, s) => e in t ? x(t, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : t[e] = s;
var d = (t, e, s) => T(t, typeof e != "symbol" ? e + "" : e, s);
const V = {
  stringify: (t) => t ? "true" : "false",
  parse: (t) => /^[ty1-9]/i.test(t)
}, _ = {
  stringify: (t) => t.name,
  parse: (t, e, s) => {
    const c = (() => {
      if (typeof window < "u" && t in window)
        return window[t];
      if (typeof global < "u" && t in global)
        return global[t];
    })();
    return typeof c == "function" ? c.bind(s) : void 0;
  }
}, $ = {
  stringify: (t) => JSON.stringify(t),
  parse: (t) => JSON.parse(t)
};
function E(t) {
  return t.replace(
    /([a-z0-9])([A-Z])/g,
    (e, s, c) => `${s}-${c.toLowerCase()}`
  );
}
function N(t) {
  return t.replace(/[-:]([a-z])/g, (e, s) => `${s.toUpperCase()}`);
}
const L = {
  stringify: (t) => t.name,
  parse: (t, e, s) => {
    const c = (() => {
      const y = N(e);
      if (typeof s < "u" && y in s.container)
        return s.container[y];
    })();
    return typeof c == "function" ? c.bind(s) : void 0;
  }
}, z = {
  stringify: (t) => `${t}`,
  parse: (t) => parseFloat(t)
}, J = {
  stringify: (t) => t,
  parse: (t) => t
}, v = {
  string: J,
  number: z,
  boolean: V,
  function: _,
  method: L,
  json: $
}, m = Symbol.for("r2wc.render"), g = Symbol.for("r2wc.connected"), l = Symbol.for("r2wc.context"), i = Symbol.for("r2wc.props");
function F(t, e, s) {
  var O, j, k;
  e.props || (e.props = t.propTypes ? Object.keys(t.propTypes) : []), e.events || (e.events = []);
  const c = Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props), y = Array.isArray(e.events) ? e.events.slice() : Object.keys(e.events), b = {}, S = {}, w = {}, A = {};
  for (const r of c) {
    b[r] = Array.isArray(e.props) ? "string" : e.props[r];
    const h = E(r);
    w[r] = h, A[h] = r;
  }
  for (const r of y)
    S[r] = Array.isArray(e.events) ? {} : e.events[r];
  class C extends HTMLElement {
    constructor() {
      super();
      d(this, k, !0);
      d(this, j);
      d(this, O, {});
      d(this, "container");
      e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this[i].container = this.container;
      for (const n of c) {
        const a = w[n], o = this.getAttribute(a), f = b[n], u = f ? v[f] : null;
        if (f === "method") {
          const p = N(a);
          Object.defineProperty(this[i].container, p, {
            enumerable: !0,
            configurable: !0,
            get() {
              return this[i][p];
            },
            set(P) {
              this[i][p] = P, this[m]();
            }
          }), this[i][n] = u.parse(o, a, this);
        }
        u != null && u.parse && o && (this[i][n] = u.parse(o, a, this));
      }
      for (const n of y)
        this[i][n] = (a) => {
          const o = n.replace(/^on/, "").toLowerCase();
          this.dispatchEvent(
            new CustomEvent(o, { detail: a, ...S[n] })
          );
        };
    }
    static get observedAttributes() {
      return Object.keys(A);
    }
    connectedCallback() {
      this[g] = !0, this[m]();
    }
    disconnectedCallback() {
      this[g] = !1, this[l] && s.unmount(this[l]), delete this[l];
    }
    attributeChangedCallback(n, a, o) {
      const f = A[n], u = b[f], p = u ? v[u] : null;
      f in b && (p != null && p.parse) && o && (this[i][f] = p.parse(o, n, this), this[m]());
    }
    [(k = g, j = l, O = i, m)]() {
      this[g] && (this[l] ? s.update(this[l], this[i]) : this[l] = s.mount(
        this.container,
        t,
        this[i]
      ));
    }
  }
  for (const r of c) {
    const h = w[r], n = b[r];
    Object.defineProperty(C.prototype, r, {
      enumerable: !0,
      configurable: !0,
      get() {
        return this[i][r];
      },
      set(a) {
        this[i][r] = a;
        const o = n ? v[n] : null;
        if (o != null && o.stringify) {
          const f = o.stringify(a, h, this);
          this.getAttribute(h) !== f && this.setAttribute(h, f);
        } else
          this[m]();
      }
    });
  }
  return C;
}
export {
  F as default
};
